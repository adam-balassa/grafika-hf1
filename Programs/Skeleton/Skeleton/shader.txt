#version 450
precision highp float;

struct Material {
	vec3 ka, kd, ks;
	float  shininess;
	vec3 F0;
	int rough, reflective;
};

struct Light {
	vec3 direction;
	vec3 Le, La;
};

struct Sphere {
	vec3 center;
	float radius;
};

struct Ellipsoid {
	vec3 center;
	float radius, scaleX, scaleY;	
};

struct Plane{
	vec3 cp, normal;
};

struct Hit {
	float t;
	vec3 position, normal;
	int mat;	// material index
};

struct Ray {
	vec3 start, dir;
};

const int nMaxObjects = 50;

uniform vec3 wEye;
uniform Light light;
uniform Material materials[20];  // diffuse, specular, ambient ref
uniform int mirrorMaterial;

uniform int nEllipsoids;
uniform Ellipsoid ellipses[nMaxObjects];

uniform int nMirrors;
uniform Plane mirrors[nMaxObjects];

in  vec3 p;					// point on camera window corresponding to the pixel
out vec4 fragmentColor;		// output that goes to the raster memory as told by glBindFragDataLocation

mat4 scaleMatrix(float scaleX, float scaleY){
	return mat4(
		scaleX, 0, 		0, 0,
		0, 		scaleY, 0, 0,
		0, 		0, 		1, 0,
		0, 		0, 		0, 1
	);
}
mat4 invScaleMatrix(float scaleX, float scaleY){
	return mat4(
		1 / scaleX, 0, 		0, 0,
		0, 		1 / scaleY, 0, 0,
		0, 		0, 			1, 0,
		0, 		0, 			0, 1
	);
}

Hit intersect(const Sphere object, const Ray ray) {
	Hit hit;
	hit.t = -1;
	vec3 dist = ray.start - object.center;
	float a = dot(ray.dir, ray.dir);
	float b = dot(dist, ray.dir) * 2.0;
	float c = dot(dist, dist) - object.radius * object.radius;
	float discr = b * b - 4.0 * a * c;
	if (discr < 0) return hit;
	float sqrt_discr = sqrt(discr);
	float t1 = (-b + sqrt_discr) / 2.0 / a;	// t1 >= t2 for sure
	float t2 = (-b - sqrt_discr) / 2.0 / a;
	if (t1 <= 0) return hit;
	hit.t = (t2 > 0) ? t2 : t1;
	hit.position = ray.start + ray.dir * hit.t;
	hit.normal = (hit.position - object.center) / object.radius;
	return hit;
}

Hit intersect(const Ellipsoid o, const Ray ray){
	Sphere sphere;
	mat4 scale = scaleMatrix(o.scaleX, o.scaleY);
	mat4 invscale = invScaleMatrix(o.scaleX, o.scaleY);
	mat4 transposeinvscale = transpose(invscale);

	sphere.center = vec3(vec4(o.center, 1) * scale);
	sphere.radius = o.radius;

	Ray trRay;
	trRay.dir = vec3(vec4(ray.dir, 1) * invscale);
	trRay.start = vec3(vec4(ray.start, 1) * invscale);
	Hit h = intersect(sphere, trRay);
	h.normal = vec3(vec4(h.normal, 1) * transposeinvscale);
	h.position = vec3(vec4(h.position, 1) * scale);
	return h;
}

Hit intersect(const Plane m, const Ray ray){
	Hit h;
	float epsilon = 0.0001;
	float p1 = dot(m.normal, ray.dir);
	vec3 x = ray.start - m.cp;
	float p2 = -dot(m.normal, x);
	float lambda = p2 / p1;
	if (lambda < 0) return h;
	vec3 p = ray.dir * lambda + ray.start;
	if(length(p) > 12.0) return h;

	h.t = lambda;
	h.normal = m.normal;
	h.position = p + h.normal * epsilon;
	h.mat = mirrorMaterial;
	return h;
}

Hit firstIntersect(Ray ray) {
	Hit bestHit;
	bestHit.t = -1;
	for (int o = 0; o < nEllipsoids; o++) {
		Hit hit = intersect(ellipses[o], ray); //  hit.t < 0 if no intersection
		hit.mat = o % 8 + 2;
		if (hit.t > 0 && (bestHit.t < 0 || hit.t < bestHit.t))  bestHit = hit;
	}
	for (int o = 0; o < nMirrors; o++) {
		Hit hit = intersect(mirrors[o], ray); //  hit.t < 0 if no intersection
		if (hit.t > 0 && (bestHit.t < 0 || hit.t < bestHit.t))  bestHit = hit;
	}
	if (dot(ray.dir, bestHit.normal) > 0) bestHit.normal = bestHit.normal * (-1);
	return bestHit;
}

bool shadowIntersect(Ray ray) {	// for directional lights
	for (int o = 0; o < nEllipsoids; o++) if (intersect(ellipses[o], ray).t > 0) return true; //  hit.t < 0 if no intersection
	for (int o = 0; o < nMirrors; o++) if (intersect(mirrors[o], ray).t > 0) return true; //  hit.t < 0 if no intersection
	return false;
}

vec3 Fresnel(vec3 F0, float cosTheta) {
	return F0 + (vec3(1, 1, 1) - F0) * pow(1 - cosTheta, 5);
}

const float epsilon = 0.0001f;
const int maxdepth = 10;

vec3 trace(Ray ray) {
	vec3 weight = vec3(1, 1, 1);
	vec3 outRadiance = vec3(0, 0, 0);
	for (int d = 0; d < maxdepth; d++) {
		Hit hit = firstIntersect(ray);
		if (hit.t < 0) return weight * light.La;
		if (materials[hit.mat].rough == 1) {
			outRadiance += materials[hit.mat].ka * light.La;
			Ray shadowRay;
			shadowRay.start = hit.position + hit.normal * 5000.0;
			shadowRay.dir = light.direction * -1;
			float cosTheta = dot(hit.normal, light.direction);
			if (cosTheta > 0 && !shadowIntersect(shadowRay)) {
				outRadiance += light.Le * materials[hit.mat].kd * cosTheta;
				vec3 halfway = normalize(-ray.dir + light.direction);
				float cosDelta = dot(hit.normal, halfway);
				if (cosDelta > 0) outRadiance += light.Le * materials[hit.mat].ks * pow(cosDelta, materials[hit.mat].shininess);
			}
			outRadiance = outRadiance * weight;
		}

		if (materials[hit.mat].reflective == 1) {
			weight *= Fresnel(materials[hit.mat].F0, dot(-ray.dir, hit.normal));
			ray.start = hit.position + hit.normal * epsilon;
			ray.dir = reflect(ray.dir, hit.normal);
		}
		else return outRadiance;
	}
}

void main() {
	Ray ray;
	ray.start = wEye;
	ray.dir = normalize(p - wEye);
	fragmentColor = vec4(trace(ray), 1);
}